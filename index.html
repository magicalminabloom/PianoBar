<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title> Mina Bloom's Song List</title>

    <!-- EmailJS Script -->
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@emailjs/browser@4/dist/email.min.js"></script>
    <script type="text/javascript">
        (function () {
            emailjs.init('rJFcYrCzL06Jkd1bq');
        })();
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #000000;
            color: #ffffff;
            padding: 40px 20px 20px 20px;
            max-width: 100%;
            width: 100%;
            margin: 0 auto;
            overflow-x: hidden;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2em;
            color: #ffffff;
        }

        /* Filter buttons container */
        .filter-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
            margin-bottom: 20px;
            padding: 20px 0;
        }

        /* Filter button styling - dark mode */
        .filter-btn {
            background-color: #000000;
            color: #ffffff;
            border: 2px solid #ffffff;
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .filter-btn.active {
            background-color: #ffffff;
            color: #000000;
        }

        /* Search container */
        .search-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 30px;
            padding: 0 10px;
            position: relative;
            transition: transform 0.25s cubic-bezier(0.25, 0.1, 0.25, 1),
                padding 0.25s cubic-bezier(0.25, 0.1, 0.25, 1),
                box-shadow 0.25s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        /* No sticky positioning - using min-height on table instead */

        .search-input {
            width: 100%;
            max-width: 500px;
            padding: 12px 20px;
            font-size: 16px;
            background-color: #000000;
            color: #ffffff;
            border: 2px solid #ffffff;
            border-radius: 8px;
            font-family: inherit;
        }

        .search-input::placeholder {
            color: #888888;
        }

        .search-clear {
            position: absolute;
            right: 20px;
            background: transparent;
            border: none;
            color: #666666;
            font-size: 24px;
            cursor: pointer;
            padding: 8px;
            line-height: 1;
            opacity: 0.6;
        }

        .search-clear:hover {
            opacity: 1;
        }

        .search-clear:active {
            opacity: 0.4;
        }

        /* Error message row - hidden by default */
        .error-message {
            display: none !important;
        }

        .error-message.show {
            display: table-row !important;
        }

        .error-message td {
            text-align: center !important;
        }

        .error-message p,
        .error-message button {
            margin-left: auto !important;
            margin-right: auto !important;
            display: block !important;
        }

        .notify-btn {
            background-color: #ffffff;
            color: #000000;
            border: 2px solid #ffffff;
            padding: 10px 20px;
            font-size: 14px;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Song table wrapper */
        .songlist-wrapper {
            width: 100%;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            padding-bottom: 60vh;
            /* Add space below table to keep search bar position stable */
            display: block;
        }

        /* Song table styling - dark mode */
        .songlist-table {
            border-collapse: collapse;
        }

        .songlist-table tbody {
            /* No fixed height - table grows naturally */
            width: 100%;
            max-width: 900px;
        }

        .songlist-table thead,
        .songlist-table tbody {
            display: table-row-group;
            /* Normal table display */
        }

        .songlist-table tbody tr {
            background-color: transparent !important;
            /* No row backgrounds */
        }

        .songlist-table tbody tr td {
            background-color: transparent !important;
            /* No cell backgrounds */
            border-bottom: none !important;
            /* No lines between rows */
        }

        /* Mobile optimization - ensure table fits in viewport */
        @media (max-width: 768px) {
            body {
                overflow-x: hidden;
                /* Allow page scroll for scroll chaining */
            }

            .songlist-wrapper {
                overflow-x: visible;
                padding: 0;
                margin: 0;
            }

            .songlist-table {
                width: 100%;
                table-layout: fixed;
            }
        }

        .songlist-table th,
        .songlist-table td {
            text-align: left;
            padding: 12px 15px;
            font-size: 16px;
            color: #ffffff;
            height: 50px;
            /* Fixed height - rows don't expand */
            max-height: 50px;
        }

        .songlist-table th {
            font-weight: bold;
            border-bottom: 2px solid #333333;
            background-color: #111111;
        }

        /* No sticky headers needed with auto-scroll approach */

        /* Column widths */
        .songlist-table th:nth-child(1),
        .songlist-table td:nth-child(1) {
            width: 40%;
        }

        .songlist-table th:nth-child(2),
        .songlist-table td:nth-child(2) {
            width: 40%;
        }

        .songlist-table th:nth-child(3),
        .songlist-table td:nth-child(3) {
            width: 20%;
            text-align: right;
        }

        /* Request button styling - dark mode */
        .request-btn {
            background-color: #000000;
            color: #ffffff;
            border: 2px solid #ffffff;
            padding: 8px 20px;
            font-size: 14px;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
            white-space: nowrap;
        }



        /* Highlight search results */
        .highlight {
            background-color: #333333;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            body {
                padding: 40px 10px 20px 10px;
                max-width: 100vw;
                overflow-x: hidden;
            }

            h1 {
                font-size: 1.5em;
                margin-bottom: 20px;
            }

            .filter-buttons {
                gap: 10px;
                padding: 15px 0;
                margin-bottom: 15px;
            }

            .filter-btn {
                padding: 10px 16px;
                font-size: 12px;
            }

            .search-input {
                max-width: 100%;
                font-size: 16px;
            }

            .search-clear {
                right: 20px;
                font-size: 22px;
            }

            .error-message p {
                font-size: 14px;
            }

            .songlist-table th,
            .songlist-table td {
                padding: 10px 8px;
                font-size: 14px;
            }

            /* Adjust column widths for mobile */
            .songlist-table th:nth-child(1),
            .songlist-table td:nth-child(1) {
                width: 35%;
            }

            .songlist-table th:nth-child(2),
            .songlist-table td:nth-child(2) {
                width: 40%;
            }

            .songlist-table th:nth-child(3),
            .songlist-table td:nth-child(3) {
                width: 25%;
            }

            .request-btn {
                padding: 6px 14px;
                font-size: 12px;
            }
        }

        /* Custom notification toast (replaces alert) */
        .custom-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #2c2c2e;
            color: #ffffff;
            padding: 20px;
            border-radius: 14px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5);
            z-index: 10000;
            text-align: center !important;
            font-size: 17px;
            font-weight: 400;
            min-width: 280px;
            max-width: 90%;
            line-height: 1.4;
            white-space: normal;
            word-wrap: break-word;
            animation: fadeIn 0.3s ease-in-out;
            display: block;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'SF Pro Display', 'Helvetica Neue', Arial, sans-serif;
        }

        .custom-notification * {
            text-align: center !important;
        }

        .custom-notification strong {
            color: #ffffff;
            font-weight: 600;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
            }

            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }

            to {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
            }
        }

        .custom-notification.fade-out {
            animation: fadeOut 0.3s ease-in-out;
        }
    </style>
</head>

<body>
    <h1>Mina Bloom's Song List</h1>

    <!-- Filter Buttons (dynamically generated) -->
    <div class="filter-buttons" id="filterButtons">
        <!-- Filters will be generated from JSON categories -->
    </div>

    <!-- Search Bar -->
    <div class="search-container" id="searchContainer">
        <input type="text" class="search-input" id="searchInput" placeholder="Search for song">
        <button class="search-clear" id="searchClear" style="display: none;">âœ•</button>
    </div>

    <!-- Song Table -->
    <div class="songlist-wrapper">
        <table class="songlist-table" id="songTable">
            <thead>
                <tr>
                    <th>Song Title</th>
                    <th>Artist / Show</th>
                    <th></th>
                </tr>
            </thead>
            <tbody id="songBody">
                <!-- Songs will be loaded here via JavaScript -->
                <!-- Error Message Row - hidden by default, shown when no songs match -->
                <tr class="error-message" id="errorMessage">
                    <td colspan="3" style="text-align: center; padding: 20px;">
                        <p id="errorText" style="margin: 0 0 15px 0; font-size: 16px;">
                            Mina doesn't know <strong id="searchTerm"></strong><br>
                            <span id="filterContext" style="font-size: 16px;"></span>
                        </p>
                        <button class="notify-btn" id="notifyBtn">Bump her to learn it</button>
                    </td>
                </tr>
                <!-- Empty rows for keyboard clearance -->
                <tr class="spacer-row">
                    <td colspan="3" style="height: 50px;">&nbsp;</td>
                </tr>
                <tr class="spacer-row">
                    <td colspan="3" style="height: 50px;">&nbsp;</td>
                </tr>
                <tr class="spacer-row">
                    <td colspan="3" style="height: 50px;">&nbsp;</td>
                </tr>
                <tr class="spacer-row">
                    <td colspan="3" style="height: 50px;">&nbsp;</td>
                </tr>
                <tr class="spacer-row">
                    <td colspan="3" style="height: 50px;">&nbsp;</td>
                </tr>
            </tbody>
        </table>
    </div>



    <script>
        // Disable browser's automatic scroll restoration
        if ('scrollRestoration' in history) {
            history.scrollRestoration = 'manual';
        }

        let allSongs = [];
        let currentFilter = 'all';
        let currentSearchTerm = '';

        // Levenshtein Distance - measures similarity between two strings
        function levenshteinDistance(str1, str2) {
            const len1 = str1.length;
            const len2 = str2.length;
            const matrix = [];

            for (let i = 0; i <= len1; i++) {
                matrix[i] = [i];
            }

            for (let j = 0; j <= len2; j++) {
                matrix[0][j] = j;
            }

            for (let i = 1; i <= len1; i++) {
                for (let j = 1; j <= len2; j++) {
                    if (str1.charAt(i - 1) === str2.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }

            return matrix[len1][len2];
        }

        // Normalize text: replace & with 'and' for consistent matching
        function normalizeText(text) {
            return text.replace(/&/g, ' and ').replace(/\s+/g, ' ').trim();
        }

        // Hybrid search: TF-IDF + N-gram + Smart ranking
        function fuzzySearch(searchTerm, songs) {
            if (!searchTerm || searchTerm.trim() === '') {
                return songs;
            }

            const term = normalizeText(searchTerm.toLowerCase().trim());
            const searchWords = term.split(/\s+/).filter(w => w.length > 0);
            const results = [];

            // Common stop words (low importance)
            const stopWords = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with']);

            songs.forEach(song => {
                const title = normalizeText(song.title.toLowerCase());
                const artist = normalizeText(song.artist.toLowerCase());
                const combined = title + ' ' + artist;
                let score = 0;
                let matchedWords = 0;
                let signals = {
                    exactPhrase: false,
                    titleStart: false,
                    allWordsMatch: false,
                    ngramMatch: false
                };

                // Signal 1: Exact phrase match (highest priority)
                if (combined.includes(term)) {
                    score += 1000;
                    signals.exactPhrase = true;
                    if (title.includes(term)) score += 500; // Bonus for title
                    if (title.startsWith(term)) score += 300; // Bonus for start
                    signals.titleStart = title.startsWith(term);
                }

                // Signal 2: For multi-word searches, require sequential/phrase matching
                const titleWords = title.split(/\s+/);
                const artistWords = artist.split(/\s+/);

                // For multi-word searches, check if words appear in sequence (with typo tolerance)
                if (searchWords.length > 1 && !signals.exactPhrase) {
                    // Helper function to check if two words match (exact, prefix, or typo)
                    const wordsMatch = (searchWord, targetWord) => {
                        // Exact match or prefix match
                        if (targetWord === searchWord || targetWord.startsWith(searchWord)) {
                            return { match: true, score: 100 };
                        }
                        // Special rule for 1-character searches: match if char appears anywhere in word
                        if (searchWord.length === 1) {
                            if (targetWord.includes(searchWord)) {
                                return { match: true, score: 60 }; // Lower score than exact match
                            }
                        }
                        // Typo tolerance for 2+ char words
                        if (searchWord.length >= 2 && Math.abs(targetWord.length - searchWord.length) <= 2) {
                            const maxDist = searchWord.length <= 5 ? 1 : 2;
                            const dist = levenshteinDistance(searchWord, targetWord);
                            if (dist <= maxDist) {
                                return { match: true, score: 80 - (dist * 10) };
                            }
                        }
                        return { match: false, score: 0 };
                    };

                    // Check title for sequential match
                    let titleSequential = false;
                    let bestTitleScore = 0;
                    for (let i = 0; i <= titleWords.length - searchWords.length; i++) {
                        let seqMatch = true;
                        let seqScore = 0;
                        for (let j = 0; j < searchWords.length; j++) {
                            const matchResult = wordsMatch(searchWords[j], titleWords[i + j]);
                            if (!matchResult.match) {
                                seqMatch = false;
                                break;
                            }
                            seqScore += matchResult.score;
                        }
                        if (seqMatch) {
                            titleSequential = true;
                            bestTitleScore = seqScore;
                            matchedWords = searchWords.length;
                            break;
                        }
                    }

                    if (titleSequential) {
                        score += 300 + bestTitleScore; // High score for sequential match in title
                    } else {
                        // Check artist for sequential match
                        for (let i = 0; i <= artistWords.length - searchWords.length; i++) {
                            let seqMatch = true;
                            let seqScore = 0;
                            for (let j = 0; j < searchWords.length; j++) {
                                const matchResult = wordsMatch(searchWords[j], artistWords[i + j]);
                                if (!matchResult.match) {
                                    seqMatch = false;
                                    break;
                                }
                                seqScore += matchResult.score;
                            }
                            if (seqMatch) {
                                score += 200 + seqScore; // Sequential in artist
                                matchedWords = searchWords.length;
                                break;
                            }
                        }
                    }

                    signals.allWordsMatch = titleSequential || score >= 200;
                } else {
                    // Single word search - use original logic
                    const allWords = [...titleWords, ...artistWords];
                    const searchWord = searchWords[0];
                    let wordMatched = false;

                    // Check for exact word match or prefix match
                    for (let word of allWords) {
                        if (word === searchWord) {
                            score += 100;
                            wordMatched = true;
                            matchedWords++;
                            break;
                        } else if (word.startsWith(searchWord)) {
                            score += 80;
                            wordMatched = true;
                            matchedWords++;
                            break;
                        }
                    }

                    // Typo tolerance for words 2+ chars
                    if (!wordMatched && searchWord.length >= 2) {
                        const maxDist = searchWord.length <= 5 ? 1 : 2;
                        for (let word of allWords) {
                            if (Math.abs(word.length - searchWord.length) <= 2) {
                                const dist = levenshteinDistance(searchWord, word);
                                if (dist <= maxDist) {
                                    score += 50 - (dist * 10);
                                    wordMatched = true;
                                    matchedWords++;
                                    break;
                                }
                            }
                        }
                    }

                    signals.allWordsMatch = wordMatched;
                }

                // Signal 3: N-gram matching (partial sequences)
                for (let i = 0; i < searchWords.length - 1; i++) {
                    const bigram = searchWords[i] + ' ' + searchWords[i + 1];
                    if (combined.includes(bigram)) {
                        score += 150;
                        signals.ngramMatch = true;
                    }
                }

                // Signal 4: TF-IDF weighting (important words matter more)
                searchWords.forEach(word => {
                    if (!stopWords.has(word)) {
                        score += 30; // Non-stop words are more important
                    }
                });

                // Signal 5: Position bonus (earlier matches rank higher)
                const firstMatchPos = combined.indexOf(searchWords[0]);
                if (firstMatchPos !== -1) {
                    score += Math.max(0, 50 - firstMatchPos);
                }

                // Signal 6: Match completeness (what % of search matched)
                const matchRatio = matchedWords / searchWords.length;
                score += matchRatio * 100;

                // Only include if we have meaningful matches (65% threshold - 5% less stringent)
                if (score > 0 && (signals.exactPhrase || signals.allWordsMatch || matchedWords >= Math.ceil(searchWords.length * 0.65))) {
                    results.push({
                        song: song,
                        score: score,
                        signals: signals
                    });
                }
            });

            // Sort by score (higher is better)
            results.sort((a, b) => {
                // Prioritize exact phrase matches
                if (a.signals.exactPhrase && !b.signals.exactPhrase) return -1;
                if (!a.signals.exactPhrase && b.signals.exactPhrase) return 1;
                // Then by score
                return b.score - a.score;
            });

            return results.map(r => r.song);
        }

        // Generate filter buttons dynamically from unique categories
        function generateFilterButtons() {
            const filterContainer = document.getElementById('filterButtons');

            // Get unique categories from all songs (case-insensitive)
            const categoriesMap = new Map(); // lowercase -> original case
            allSongs.forEach(song => {
                if (song.tags && Array.isArray(song.tags)) {
                    song.tags.forEach(tag => {
                        const lowerTag = tag.toLowerCase();
                        // Keep the first capitalization we encounter
                        if (!categoriesMap.has(lowerTag)) {
                            categoriesMap.set(lowerTag, tag);
                        }
                    });
                }
            });

            // Convert to sorted array (by lowercase for consistent sorting)
            const sortedCategories = Array.from(categoriesMap.entries())
                .sort((a, b) => a[0].localeCompare(b[0]))
                .map(entry => entry[1]); // Get original capitalization

            // Clear existing buttons
            filterContainer.innerHTML = '';

            // Add "All Songs" button first
            const allButton = document.createElement('button');
            allButton.className = 'filter-btn active';
            allButton.setAttribute('data-filter', 'all');
            allButton.textContent = 'All Songs';
            filterContainer.appendChild(allButton);

            // Add category buttons
            sortedCategories.forEach(category => {
                const button = document.createElement('button');
                button.className = 'filter-btn';
                button.setAttribute('data-filter', category);
                button.textContent = category.toUpperCase(); // Display in uppercase
                filterContainer.appendChild(button);
            });

            // Set up click handlers for all filter buttons
            document.querySelectorAll('.filter-btn').forEach(button => {
                button.addEventListener('click', function () {
                    // Update active state
                    document.querySelectorAll('.filter-btn').forEach(btn =>
                        btn.classList.remove('active')
                    );
                    this.classList.add('active');

                    // Update filter and re-render
                    currentFilter = this.getAttribute('data-filter');
                    renderSongs();
                });
            });
        }

        // Load songs from JSON
        async function loadSongs() {
            try {
                const response = await fetch('mina-bloom-songs.json');
                allSongs = await response.json();
                generateFilterButtons(); // Generate filters after loading songs
                renderSongs();
            } catch (error) {
                console.error('Error loading songs:', error);
                document.getElementById('songBody').innerHTML =
                    '<tr><td colspan="3" style="text-align: center; padding: 20px;">Error loading songs. Please try again later.</td></tr>';
            }
        }

        // Render songs based on current filter and search
        function renderSongs() {
            const tbody = document.getElementById('songBody');
            const errorMessage = document.getElementById('errorMessage');

            // Clear only song rows, keep error message row and spacer rows
            const rows = tbody.querySelectorAll('tr:not(.error-message):not(.spacer-row)');
            rows.forEach(row => row.remove());

            // Special handling for Holiday filter
            let filteredSongs = allSongs;

            if (currentSearchTerm) {
                // SPECIAL CASE: If in Holiday filter, search ONLY holiday songs
                if (currentFilter.toLowerCase() === 'holiday') {
                    const holidaySongs = allSongs.filter(song =>
                        song.tags && song.tags.some(tag => tag.toLowerCase() === 'holiday')
                    );
                    filteredSongs = fuzzySearch(currentSearchTerm, holidaySongs);
                } else if (currentFilter.toLowerCase() === 'all') {
                    // "All" filter: search ALL songs INCLUDING holiday
                    filteredSongs = fuzzySearch(currentSearchTerm, allSongs);
                } else {
                    // Other filters (Country, Rock, etc): search ALL songs EXCEPT holiday
                    const nonHolidaySongs = allSongs.filter(song =>
                        !song.tags || !song.tags.some(tag => tag.toLowerCase() === 'holiday')
                    );
                    filteredSongs = fuzzySearch(currentSearchTerm, nonHolidaySongs);
                }
            } else if (currentFilter !== 'all') {
                // No search term, apply filter normally (case-insensitive)
                filteredSongs = allSongs.filter(song =>
                    song.tags && song.tags.some(tag => tag.toLowerCase() === currentFilter.toLowerCase())
                );
            }
            // else: No search, "All" filter: show all songs (allSongs already set)

            // Show error if no results
            if (currentSearchTerm && filteredSongs.length === 0) {
                errorMessage.classList.add('show');

                // Different error message for Holiday filter
                const errorText = document.getElementById('errorText');
                const searchTermElement = document.getElementById('searchTerm');

                if (currentFilter.toLowerCase() === 'holiday') {
                    errorText.innerHTML = `Mina doesn't know the holiday song<br><strong>${currentSearchTerm}</strong>`;
                } else {
                    errorText.innerHTML = `Mina doesn't know <strong id="searchTerm">${currentSearchTerm}</strong>`;
                }
            } else {
                errorMessage.classList.remove('show');
            }

            // Sort alphabetically by title
            filteredSongs.sort((a, b) =>
                a.title.toLowerCase().localeCompare(b.title.toLowerCase())
            );

            // Render songs
            filteredSongs.forEach(song => {
                const row = document.createElement('tr');

                const titleCell = document.createElement('td');
                titleCell.textContent = song.title;

                const artistCell = document.createElement('td');
                artistCell.textContent = song.artist;

                const requestCell = document.createElement('td');

                // Unified behavior for all platforms
                const venmoNote = `Song Request: ${song.title} - ${song.artist}`;
                const requestLink = document.createElement('a');
                requestLink.href = `venmo://paycharge?txn=pay&recipients=mina-bloom-1&amount=5&note=${encodeURIComponent(venmoNote)}`;
                requestLink.className = 'request-btn';
                requestLink.textContent = 'Request';

                // Add click handler to detect if Venmo isn't installed
                requestLink.addEventListener('click', function (e) {
                    setTimeout(() => {
                        if (document.visibilityState === 'visible') {
                            showNotification(`No Venmo?<br>Bring cash to the piano<br>to request <strong>${song.title}</strong>`, 4000);
                        }
                    }, 1000);
                });

                requestCell.appendChild(requestLink);

                row.appendChild(titleCell);
                row.appendChild(artistCell);
                row.appendChild(requestCell);

                // Insert before error message (which is followed by spacer rows)
                tbody.insertBefore(row, errorMessage);
            });
        }

        const searchInput = document.getElementById('searchInput');

        // Add extra scroll on focus to show more of the table
        searchInput.addEventListener('focus', function () {
            // Detect iOS vs Android
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
            const isAndroid = /Android/.test(navigator.userAgent);

            // Platform-specific offsets and delays
            let scrollOffset = 150; // Default
            let delay = 200; // Default

            if (isIOS) {
                scrollOffset = 125;
                delay = 200;
            } else if (isAndroid) {
                scrollOffset = 100;
                delay = 400; // Android needs more time for keyboard animation
            }

            // Wait for browser's scroll-into-view, then adjust
            setTimeout(() => {
                const currentScroll = window.pageYOffset;
                window.scrollTo({
                    top: currentScroll + scrollOffset,
                    behavior: 'smooth'
                });
            }, delay);
        });

        // Live search - filter as user types
        const searchClear = document.getElementById('searchClear');

        searchInput.addEventListener('input', function () {
            currentSearchTerm = this.value;

            // Show/hide clear button
            if (currentSearchTerm.length > 0) {
                searchClear.style.display = 'block';
            } else {
                searchClear.style.display = 'none';
            }

            renderSongs();
        });

        // Clear button click handler
        searchClear.addEventListener('click', function () {
            searchInput.value = '';
            currentSearchTerm = '';
            searchClear.style.display = 'none';
            renderSongs();
            searchInput.focus();
        });



        // Custom notification function (replaces alert to avoid domain prefix)
        function showNotification(message, duration = 3000) {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = 'custom-notification';
            notification.innerHTML = message; // Use innerHTML to support HTML like <strong>

            // Add to body
            document.body.appendChild(notification);

            // Auto-remove after duration
            setTimeout(() => {
                notification.classList.add('fade-out');
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300); // Match fadeOut animation duration
            }, duration);
        }

        // Notify button - EmailJS Integration
        document.getElementById('notifyBtn').addEventListener('click', function () {
            const searchTerm = document.getElementById('searchTerm').textContent;

            // Send email via EmailJS
            emailjs.send('service_9n4pqrq', 'template_hx37uza', {
                song_request: searchTerm
            }).then(
                function (response) {
                    showNotification('Thanks! Mina has been notified to learn "' + searchTerm + '"!');
                    console.log('Email sent successfully!', response.status, response.text);
                },
                function (error) {
                    showNotification('Oops! Something went wrong. Please try again.');
                    console.log('Email failed to send:', error);
                }
            );
        });

        // Load songs on page load
        loadSongs();
    </script>
</body>

</html>
